// Однородный бинарный поиск
// Храним "указатель" на середину, затем с помощью шага меняем его положение
// Сам шаг уменьшается с каждом шагом

#include <iostream>

int u_b_s(int* ar, int n, int k) {
	int h = n / 2; // Шаг
	int i = n / 2 - (n % 2 == 0); // У алгоритма есть проблема с четным размером массива
	// вычитание единицы при четных n решает данную проблему
	while (true) {
		if (ar[i] == k) {
			return i;
		}
		else if (k < ar[i]) {
			i -= (h + 1) / 2;
		}
		else {
			i += (h + 1) / 2;
		}
		if (h == 0) {
			return -1;
		}
		h /= 2;
	}
}

int main() {
	int ar[] = { 0, 1, 2, 3, 4, 6, 8 };
	for (int i = -3; i <= 10; ++i) {
		std::cout << i << " " << u_b_s(ar, 8, i) << '\n';
	}
}